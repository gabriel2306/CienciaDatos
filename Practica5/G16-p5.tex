\documentclass [a4paper] {article}

\usepackage[spanish]{babel} 
\usepackage[utf8]{inputenc} 
\usepackage{multirow} 
\usepackage{float} 

\title{R-PL5}
\author{Gabriel López Cuenca, Sergio Sanz Sacristán, Álvaro Zamorano Ortega}

\usepackage{Sweave}
\begin{document}
\input{G16-p5-concordance}

\maketitle

\graphicspath{ {./tmp/} }

\section{Ejercicio realizado en clase.}

\subsection{K-vecinos}
\bigskip
A partir del siguiente conjunto de calificaciones académicas,formados por dos notas: teoría y laboratorio, 
que tendrán valores entre 0 y 5, realizar un análisis de detección de datos anómalos utilizando el algoritmo
\textbf{K-vecinos}.

\begin{table}[H]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
Alumno & Teoría & Laboratorio\\
\hline \hline
A1 & 4 & 4 \\ \hline
A2 & 4 & 3 \\ \hline
A3 & 5 & 5 \\ \hline
A4 & 1 & 1 \\ \hline
A5 & 5 & 4 \\ \hline
\end{tabular}
\end{center}
\end{table}

En primer lugar se introducirán los datos en forma de matriz y se hará la traspuesta de esta.
\begin{Schunk}
\begin{Sinput}
> muestra = matrix(c(4,4,4,3,5,5,1,1,5,4),2,5)
> muestra = t(muestra)
\end{Sinput}
\end{Schunk}

\bigskip
En segundo lugar, calculamos las distancias euclídeas entre todos los puntos y los almacenamos 
en una matriz. El cálculo de las distancias lo realizamos mediante la función \textbf{as.matrix}. 

\bigskip
\begin{Schunk}
\begin{Sinput}
> distancias = as.matrix(dist(muestra))
> distancias = matrix(distancias,5,5)
\end{Sinput}
\end{Schunk}

\bigskip
En tercer lugar, ordenamos las columnas de la matriz de distancias por los valores de cada una de
las filas de menor a mayor. Se tiene en cuenta el \textbf{tercer} vecino, por lo que debemos estudiar la cuarta 
fila de la matriz ya que se tiene en cuenta la distancia de un punto consigo mismo. Se obtienen las 
muestras cuyo suceso es anómalo o outlier, el grado de outlier es \texttt{2.5.}
\begin{Schunk}
\begin{Sinput}
> source("./Funciones/anomalosKVecinos.R")
> anomalosKVecinos
\end{Sinput}
\begin{Soutput}
function (distancias, muestra, k, grado,dimensiones) {
    tmp<-""

    for(i in 1:(length(muestra)/dimensiones)){
        distancias[,i] = sort(distancias[,i])
        if(distancias[k+1,i] > grado) {
            valor<-""
            for (j in 1:dimensiones){
                valor<-paste(valor,muestra[k+1,j],sep=" ")
            }
            tmp<-paste(tmp,"La muestra ", i, 
                " con valor (", valor, " ) es outlier - ",sep="")
        }
    }

    return(tmp)
}
\end{Soutput}
\end{Schunk}

\bigskip
Procedemos a su ejecución:
\begin{Schunk}
\begin{Sinput}
> (anomalosKVecinos(distancias,muestra,3,2.5,2))
\end{Sinput}
\begin{Soutput}
[1] "La muestra 4 con valor ( 1 1 ) es outlier - "
\end{Soutput}
\end{Schunk}

\bigskip
Es importante indicar que la función necesita conocer el número de \textbf{dimensiones} que tiene
la muestra.

\subsection{Caja y bigotes.}
\bigskip
A partir del siguiente conjunto de valores de resistencia y densidad para diferentes tipos de hormigón,
se hará un análisis para la detección de outliers utilizando medidas de ordenación sobre la resistencia
con el método de \textbf{Caja y Bigotes}.

\begin{table}[H]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
Hormigón & Resistencia & Densidad\\
\hline \hline
H1 & 3 & 2 \\ \hline
H2 & 3.5 & 12 \\ \hline
H3 & 4.7 & 4.1 \\ \hline
H4 & 5.2 & 4.9 \\ \hline
H5 & 7.1 & 6.1 \\ \hline
H6 & 6.2 & 5.2 \\ \hline
H7 & 14 & 5.3 \\ \hline
\end{tabular}
\end{center}
\end{table}

\bigskip
En primer lugar, introducimos los datos en una matriz y lo convertimos a dataframe para que el trabajo con las 
columnas sea más cómodo.
\begin{Schunk}
\begin{Sinput}
> muestra = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,4.9,7.1,6.1,6.2,5.2,14,5.3),
+         2,7,dimnames = list(c("r","d"))))
> muestra = data.frame(muestra)
\end{Sinput}
\end{Schunk}

\bigskip
En segundo lugar:
\begin{enumerate}
\item Se determina el grado de outlier de forma arbitraria. El valor dado es \texttt{1.5}.
\item Se ordenan los datos y se obtienen los cuartiles.
\begin{Schunk}
\begin{Sinput}
> (cuar1 <- quantile(muestra$r,0.25))
\end{Sinput}
\begin{Soutput}
25% 
4.1 
\end{Soutput}
\begin{Sinput}
> (cuar3 <- quantile(muestra$r,0.75))
\end{Sinput}
\begin{Soutput}
 75% 
6.65 
\end{Soutput}
\end{Schunk}

\item Se calculan los límites del intervalo.
\begin{Schunk}
\begin{Sinput}
> (int = c(cuar1 - 1.5 * (cuar3 - cuar1),cuar3 + 1.5*(cuar3-cuar1)))
\end{Sinput}
\begin{Soutput}
   25%    75% 
 0.275 10.475 
\end{Soutput}
\end{Schunk}

\item Se identifican como outliers los valores que quedan fuera del intervalo. Para ello 
hemos creado una función:
\begin{Schunk}
\begin{Sinput}
> source("./Funciones/sucesosAnomalos.R")
> sucesosAnomalos
\end{Sinput}
\begin{Soutput}
function (muestra, intervalo) {
    tmp<-""

    for(i in 1:length(muestra)){
        if(muestra[i] < intervalo[1] || muestra[i] > intervalo[2]){
            tmp<-paste(tmp, "El suceso ", i, " con valor ", muestra[i],
            " es un outlier - ", sep="")
        }
    }
    
    return(tmp)
}
\end{Soutput}
\end{Schunk}

\bigskip
Procedemos a su ejecución:
\begin{Schunk}
\begin{Sinput}
> (sucesosAnomalos(muestra$r,int))
\end{Sinput}
\begin{Soutput}
[1] "El suceso 7 con valor 14 es un outlier - "
\end{Soutput}
\end{Schunk}
\end{enumerate}

\bigskip
Por último, mostramos el diagrama de caja y bigotes donde se identifica el valor anómalo.
\begin{Schunk}
\begin{Sinput}
> source("./Funciones/Bigotes.R")
> bigotes(muestra$r,"bigotes.png",1.5)
\end{Sinput}
\end{Schunk}
\includegraphics[width=\textwidth]{bigotes}

\subsection{Desviación Típica.}
\bigskip
Ahora con los mismos datos del apartado anterior deseamos realizar un análisis de detección de datos 
anómalos utilizando medidas de dispersión sobre la densidad con el método de \textbf{Desviación Típica}.
\begin{enumerate}
\item Se determina el grado de outlier de forma arbitraria. El valor dado es \texttt{2}.
\item Se obtiene la media aritmética.
\begin{Schunk}
\begin{Sinput}
> (media<-mean(muestra$d))
\end{Sinput}
\begin{Soutput}
[1] 5.657143
\end{Soutput}
\end{Schunk}
\item Se obtiene la desviación típica.
\begin{Schunk}
\begin{Sinput}
> sdd<-sd(muestra$d)
> (desviacion<-sqrt((sdd^2)*((length(muestra$d)-1)/length(muestra$d))))
\end{Sinput}
\begin{Soutput}
[1] 2.857
\end{Soutput}
\end{Schunk}
\item Y por último, se calculan los límites del intervalo para los valores atípicos.
\begin{Schunk}
\begin{Sinput}
> (intdes<-c(media-2*desviacion,media+2*desviacion))
\end{Sinput}
\begin{Soutput}
[1] -0.05685714 11.37114285
\end{Soutput}
\end{Schunk}
\item Se identifican como outliers los valores que quedan fuera del intervalo. Para ello
hemos creado una función:
\begin{Schunk}
\begin{Sinput}
> source("./Funciones/sucesosAnomalos.R")
> sucesosAnomalos
\end{Sinput}
\begin{Soutput}
function (muestra, intervalo) {
    tmp<-""

    for(i in 1:length(muestra)){
        if(muestra[i] < intervalo[1] || muestra[i] > intervalo[2]){
            tmp<-paste(tmp, "El suceso ", i, " con valor ", muestra[i],
            " es un outlier - ", sep="")
        }
    }
    
    return(tmp)
}
\end{Soutput}
\end{Schunk}

\bigskip
Procedemos a su ejecución:
\begin{Schunk}
\begin{Sinput}
> (sucesosAnomalos(muestra$d,intdes))
\end{Sinput}
\begin{Soutput}
[1] "El suceso 2 con valor 12 es un outlier - "
\end{Soutput}
\end{Schunk}
\end{enumerate}

\subsection{Regresión.}
\bigskip
Con los mismos datos de los apartados anteriores deseamos realizar un análisis de detección de datos 
anómalos sobre la regresión de las variables, densidad en función de la resistencia, utilizando el
error estándar de los residuos con el método de \textbf{Regresión}.
\begin{enumerate}
\item Se determina el grado de outlier de forma arbitraria. El valor dado es \texttt{2}.
\item Se obtiene la regresión lineal.
\begin{Schunk}
\begin{Sinput}
> (dfr<-lm(muestra$d~muestra$r))
\end{Sinput}
\begin{Soutput}
Call:
lm(formula = muestra$d ~ muestra$r)

Coefficients:
(Intercept)    muestra$r  
    6.01445     -0.05723  
\end{Soutput}
\end{Schunk}
\item Se obtiene el Error Estándar de los residuos.
\begin{Schunk}
\begin{Sinput}
> res<-summary(dfr)$residuals
> (sr=sqrt(sum(res^2)/7))
\end{Sinput}
\begin{Soutput}
[1] 2.850242
\end{Soutput}
\end{Schunk}
\item Se calcula el límite para considerar atípico un valor siguiendo la ecuación 
\texttt{Grado outlier * Error estándar}.
\begin{Schunk}
\begin{Sinput}
> (intSr<-(2*sr))
\end{Sinput}
\begin{Soutput}
[1] 5.700484
\end{Soutput}
\end{Schunk}
\item Se identifican los outliers como aquellos tales que \texttt{|yObservada - yCalculada| > limite}.
El valor de |yObservada - yCalculada| es cada uno de los residuos.
\begin{Schunk}
\begin{Sinput}
> source("./Funciones/anomalosRegresion.R")
> anomalosRegresion
\end{Sinput}
\begin{Soutput}
function (residuos, limite, muestra) {
    tmp<-""

    for(i in 1:length(residuos)){
        if(residuos[i]>limite){
            tmp<-paste(tmp,"El suceso ", i, 
                " con valor (", muestra$r[i]," ",
                 muestra$d[i], ") es outlier - ",sep="")
        }
    }

    return(tmp)
}
\end{Soutput}
\end{Schunk}
\bigskip
Procedemos a su ejecución:
\begin{Schunk}
\begin{Sinput}
> (anomalosRegresion(res, intSr, muestra))
\end{Sinput}
\begin{Soutput}
[1] "El suceso 2 con valor (3.5 12) es outlier - "
\end{Soutput}
\end{Schunk}
\end{enumerate}

\bigskip
\section{Desarrollo de métodos.}
\bigskip
Como en el apartado anterior hemos desarrollado el método de K-vecinos, ahora hemos buscado
otros paquetes capaces de encontrar los outliers de una muestra realizando éste mismo método.
\subsection{Paquete <adamethods>}
\bigskip
En primer lugar hemos encontrado el paquete \textbf{adamethods}, el cual necesita previamente
\textbf{shapes}.
\begin{Schunk}
\begin{Sinput}
> install.packages("shapes")
> library(shapes)
> install.packages("adamethods")
> library(adamethods)
\end{Sinput}
\end{Schunk}
\bigskip
Vamos a utilizar la función \textbf{do\_knno()} que forma parte del paquete adamethods, la cual
nos devuelve los números de las muestras que son outliers. Para ello primero vamos a introducir
la muestra con la que vamos a trabajar, la cual es la utilizada en el apartado 1.1.
\begin{Schunk}
\begin{Sinput}
> muestra = matrix(c(4,4,4,3,5,5,1,1,5,4),2,5)
> muestra = t(muestra)
> data = as.matrix(muestra)
\end{Sinput}
\end{Schunk}
\bigskip
Para usar la función debemos introducir la muestra, el número de vecino con el que queremos trabajar
(en este caso 3) y el número de outliers que queremos obtener. Por esta última característica 
consideramos que el funcionamiento del paquete no es adecuado ya que se recomienda indicar el grado
de outlier, y con ello el rango de valores permitidos.

\bigskip
Además aunque al calcular el número de outliers de la forma indicada en el apartado 1.1 nos salgan 2,
si al realizar está función le introducimos que solo nos calcule 1 outlier, solo nos devolverá 1.
Por lo tanto, la función no se corresponde con la realidad.

\bigskip
Procedemos a llamar a la función.
\begin{Schunk}
\begin{Sinput}
> out <- do_knno(data,3,1)
> (data[out,])
\end{Sinput}
\begin{Soutput}
[1] 1 1
\end{Soutput}
\end{Schunk}

\subsection{Paquete <outliers>}
\bigskip
Ahora hemos estudiado el paquete \textbf{outliers}, el cual nos devuelve un outlier de la muestra.
\begin{Schunk}
\begin{Sinput}
> install.packages("outliers")
> library(outliers)
\end{Sinput}
\end{Schunk}
\bigskip
Una vez que inicializamos el paquete a utilizar introducimos la muestra de datos, la cual corresponde
con la utilizada en el apartado anterior y en el apartado 1.1 para comparar los resultados.
\begin{Schunk}
\begin{Sinput}
> muestra = matrix(c(4,4,4,3,5,5,1,1,5,4),2,5)
> muestra = t(muestra)
> data = as.matrix(muestra)
\end{Sinput}
\end{Schunk}
\bigskip
Una vez introducidos los datos de la muestra procedemos a encontrar los outliers utilizando la función
del paquete \textbf{outlier()}. A esta función hay que pasarle como parámetro la muestra de datos introducida,
y esta nos devolverá un outlier, es decir, solo un outlier, si por ejemplo en el apartado 1.1 la función
K-Vecino nos devuelve más de un outlier, esta función tan solo nos va a devolver uno de esos outliers. Incluso
si no detecta ningúna outlier nuestra función, aqui nos dará uno de los datos de la muestra como outlier.
Por esto consideramos que la funcionalidad de este paquete no es óptima.

\bigskip
Procedemos a llamar a la función.
\begin{Schunk}
\begin{Sinput}
> outlier(data)
\end{Sinput}
\begin{Soutput}
[1] 1 1
\end{Soutput}
\end{Schunk}

\end{document}
